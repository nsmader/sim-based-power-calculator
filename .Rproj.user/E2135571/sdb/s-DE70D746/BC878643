{
    "contents" : "#----------------------\n### CONTINUOUS OUTCOMES\n#----------------------\n  ##Functional form for R to do root-finding for effect size\n    helper_effsize <- function (eff.size, cluster.num, cluster.size, power, resid.var, cluster.var, alpha){\n      N = cluster.size*cluster.num\n      invV = solve(resid.var*diag(cluster.size) + cluster.var)\n      a = sum(invV[,1])\n      V = solve( cbind ( c(2*N*a, N*a), rep(N*a, 2)) )\n      SE = sqrt(V[2,2])\n      1+pnorm (qnorm(alpha/2)-eff.size/SE) - pnorm (qnorm(1-alpha/2)-eff.size/SE)-power\n    }\n    \n  ##Function to calculate power\n    helper_power <- function (eff.size, cluster.num, cluster.size, resid.var, cluster.var, alpha){\n      N = cluster.size*cluster.num\n      invV = solve(resid.var*diag(cluster.size) + cluster.var)\n      a = sum(invV[,1])\n      V = solve( cbind ( c(2*N*a, N*a), rep(N*a, 2)) )\n      SE = sqrt(V[2,2])\n      1+pnorm (qnorm(alpha/2)-eff.size/SE) - pnorm (qnorm(1-alpha/2)-eff.size/SE)\n    }\n\n  #---------------------------\n  # Cluster-randomized Designs\n  #---------------------------\n    \n    ctsClus_getEffectSize_clusterNum <- function (clusterNum.list, cluster.size, power, resid.var, cluster.var, alpha){\n      f = function(x){ uniroot (helper_effsize, interval = c(0, 100), \n                                                cluster.num = x, \n                                                cluster.size = cluster.size,\n                                                power = power,\n                                                resid.var = resid.var,\n                                                cluster.var = cluster.var,\n                                                alpha = alpha)$root}\n      sapply(clusterNum.list, function(x){f(x)} )\n    }\n    \n    ctsClus_getEffectSize_clusterSize <- function (clusterSize.list, cluster.num, power, resid.var, cluster.var, alpha){\n      f = function(x){ uniroot (helper_effsize, interval = c(0, 100),\n                                                cluster.size = x,\n                                                cluster.num = cluster.num,\n                                                power = power,\n                                                resid.var = resid.var,\n                                                cluster.var = cluster.var,\n                                                alpha = alpha)$root}\n      sapply(clusterSize.list, function(x){f(x)} )\n    }\n    \n    ctsClus_getclusterSize_effectSize <- function (effectSize.list, cluster.num, power, resid.var, cluster.var, alpha){\n      \n      clusterSize.seq = 1:200\n      f = function(y){ \n        power.list = sapply(clusterSize.seq, \n                            function(x){helper_power(cluster.size = x,\n                                                     eff.size = y,\n                                                     cluster.num = cluster.num,\n                                                     resid.var = resid.var,\n                                                     cluster.var = cluster.var,\n                                                     alpha = alpha)} ) \n        check = power.list > power\n        if ( sum(check)>=1 ){ clusterSize.seq[min(which(check))]} else{NA}\n      }\n      sapply(effectSize.list, function(x){f(x)} )\n    }  \n    \n    ctsClus_getclusterNum_effectSize <- function (effectSize.list, cluster.size, power, resid.var, cluster.var, alpha){\n    \n      clusterNum.seq = 1:200\n      f = function(y){ \n        power.list = sapply(clusterNum.seq, \n                            function(x){helper_power(cluster.num = x,\n                                                     eff.size = y,\n                                                     cluster.size = cluster.size,\n                                                     resid.var = resid.var,\n                                                     cluster.var = cluster.var,\n                                                     alpha = alpha)} ) \n        check = power.list > power\n        if ( sum(check)>=1 ){ clusterNum.seq[min(which(check))]} else{NA}\n      }\n      sapply(effectSize.list, function(x){f(x)} )\n    }  \n    \n    ctsClus_getpower_effectSize <- function (effectSize.list, cluster.num, cluster.size, resid.var, cluster.var, alpha){\n      sapply(effectSize.list, function(x){\n        helper_power (eff.size = x,\n                      cluster.num = cluster.num,\n                      cluster.size = cluster.size,\n                      resid.var = resid.var,\n                      cluster.var = cluster.var, \n                      alpha = alpha) } \n      )\n    }  \n\n  ctsClus_getClusterSize_clusterNum <- function (clusterNum.list, effect.size, resid.var, cluster.var, alpha){\n    \n    clusterSize.seq = seq(1, 200, by = 4)\n    f = function(y){ \n      power.list = sapply(clusterSize.seq, \n                          function(x){helper_power(eff.size = effect.size,\n                                                   cluster.num = y,\n                                                   cluster.size = x,\n                                                   resid.var = resid.var,\n                                                   cluster.var = cluster.var,\n                                                   alpha = alpha)} ) \n      check = power.list > power\n      if ( sum(check)>=1 ){ clusterSize.seq[min(which(check))]} else{NA}\n    }\n    sapply(clusterNum.list, function(x){f(x)} )\n  }\n\n\n  #------------------------------\n  # Individual-randomized Designs\n  #------------------------------\n\n    # Rather than creating specialized functions, we use the clustered ones and \n    # fill in cluster.var = 0 and cluster.num = 1\n\n#------------------\n### BINARY OUTCOMES\n#------------------\n\n",
    "created" : 1437106957107.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "2322561607",
    "id" : "BC878643",
    "lastKnownWriteTime" : 1437175748,
    "path" : "~/GitHub/sim-based-power-calculator/global.R",
    "project_path" : "global.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}