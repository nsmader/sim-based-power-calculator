{
    "contents" : "#----------------------\n### CONTINUOUS OUTCOMES\n#----------------------\n  ##Functional form for R to do root-finding for effect size\n    helper_effsize <- function (eff.size, cluster.num, cluster.size, power, resid.var, cluster.var, alpha){\n      N = cluster.size*cluster.num\n      invV = solve(resid.var*diag(cluster.size) + cluster.var)\n      a = sum(invV[,1])\n      V = solve( cbind ( c(2*N*a, N*a), rep(N*a, 2)) )\n      SE = sqrt(V[2,2])\n      1+pnorm (qnorm(alpha/2)-eff.size/SE) - pnorm (qnorm(1-alpha/2)-eff.size/SE)-power\n    }\n    \n  ##Function to calculate power\n    helper_power <- function (eff.size, cluster.num, cluster.size, resid.var, cluster.var, alpha){\n      N = cluster.size*cluster.num\n      invV = solve(resid.var*diag(cluster.size) + cluster.var)\n      a = sum(invV[,1])\n      V = solve( cbind ( c(2*N*a, N*a), rep(N*a, 2)) )\n      SE = sqrt(V[2,2])\n      1+pnorm (qnorm(alpha/2)-eff.size/SE) - pnorm (qnorm(1-alpha/2)-eff.size/SE)\n    }\n\n  #---------------------------\n  # Cluster-randomized Designs\n  #---------------------------\n    \n    ctsClus_getEffectSize_clusterNum <- function (clusterNum.list, cluster.size, power, resid.var, cluster.var, alpha){\n      f = function(x){ uniroot (helper_effsize, interval = c(0, 100), cluster.size, cluster.num = x, power, resid.var, cluster.var, alpha)$root}\n      sapply(clusterNum.list, function(x){f(x)} )\n    }\n    \n    ctsClus_getEffectSize_clusterSize <- function (clusterSize.list, cluster.num, power, resid.var, cluster.var, alpha){\n      f = function(x){ uniroot (helper_effsize, interval = c(0, 100), cluster.size = x, cluster.num, power, resid.var, cluster.var, alpha)$root}\n      sapply(clusterSize.list, function(x){f(x)} )\n    }\n    \n    ctsClus_getclusterSize_effectSize <- function (effectSize.list, cluster.num, power, resid.var, cluster.var, alpha){\n      \n      clusterSize.seq = 1:200\n      f = function(y){ \n        power.list = sapply(clusterSize.seq, \n                            function(x){helper_power(eff.size = y, cluster.num, cluster.size=x, resid.var, cluster.var, alpha)} ) \n        check = power.list > power\n        if ( sum(check)>=1 ){ clusterSize.seq[min(which(check))]} else{NA}\n      }\n      sapply(effectSize.list, function(x){f(x)} )\n    }  \n    \n    ctsClus_getclusterNum_effectSize <- function (effectSize.list, cluster.size, power, resid.var, cluster.var, alpha){\n    \n      clusterNum.seq = 1:200\n      f = function(y){ \n        power.list = sapply(clusterNum.seq, \n                            function(x){helper_power(eff.size = y, cluster.num=x, cluster.size, resid.var, cluster.var, alpha)} ) \n        check = power.list > power\n        if ( sum(check)>=1 ){ clusterNum.seq[min(which(check))]} else{NA}\n      }\n      sapply(effectSize.list, function(x){f(x)} )\n    }  \n    \n    ctsClus_getpower_effectSize <- function (effectSize.list, cluster.num, cluster.size, resid.var, cluster.var, alpha){\n      sapply(effectSize.list, function(x){\n        helper_power (eff.size=x, cluster.num, cluster.size, resid.var, cluster.var, alpha) } \n      )\n    }  \n\n\n  #------------------------------\n  # Individual-randomized Designs\n  #------------------------------\n\n#     ctsIndiv_getPower <- function(sampleSize, effectSize){\n#       return(runif(1))\n#     }\n# \n#     ctsIndiv_getEffectSize <- function(sampleSize, power){\n#       return(rnorm(1))\n#     }\n#     ctsIndiv_getSampleSize <- function(effectSize, power){\n#       return(round(runif(1)*100, 0))\n#     }\n\n#------------------\n### BINARY OUTCOMES\n#------------------\n\n",
    "created" : 1437106957107.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "280692255",
    "id" : "BC878643",
    "lastKnownWriteTime" : 1437106132,
    "path" : "~/GitHub/sim-based-power-calculator/global.R",
    "project_path" : "global.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}