{
    "contents" : "### Server-side code for dispatching runs of simulation-based power calculations ###\n\nlibrary(lme4)\nlibrary(shiny)\nlibrary(shinyapps)\nlibrary(foreach)\nlibrary(doParallel)\nlibrary(ggplot2)\n\n# See following links for ideas on debugging Shiny apps code\n# http://stackoverflow.com/questions/23002712/shiny-what-is-the-option-setting-to-display-in-the-console-the-messages-between\n# ... which recommends the command: options(shiny.trace=TRUE)\n# http://rstudio.github.io/shiny/tutorial/#run-and-debug\noptions(shiny.trace=FALSE)\n\nshinyServer(function(input, output){\n  \n  alpha     <- reactive(as.numeric(input$alpha))\n  resid.var <- reactive(as.numeric(input$resid.sd)^2)\n  \n  # Make modifications if not using a clustered design\n  cluster.num <- reactive(ifelse(input$clusterDesign == FALSE, 1, as.numeric(input$cluster.num)))\n  cluster.ICC <- reactive(ifelse(input$clusterDesign == FALSE, 0, as.numeric(input$cluster.ICC)))\n  #cluster.var <- reactive(ifelse(input$clusterDesign == FALSE, 0, cluster.ICC()*pi^2/3)/(1-cluster.ICC()))\n    # This is functional relationship between ICC and variance is for logistic errors...\n  cluster.var <- reactive(ifelse(input$clusterDesign == FALSE, 0, cluster.ICC()*resid.var()/(1-cluster.ICC())))\n  \n  output$plotOut <- renderPlot({\n    input$updateCalc # This reruns this code when the \"updateCalc\" button in the UI is clicked\n  {\n  if (input$outcomeType == \"Continuous\"){\n    \n    if (input$clusterDesign == T){\n      \n      # 1. specify power and effect size --> receive cluster size vs. # clusters (discrete)\n        # /!\\ Minor note--could redo this sequence of if()s to be a switch()\n        if (input$clusterRequest == \"cluster size vs. # clusters\"){\n          \n          power       <- reactive(as.numeric(input$power_sn))\n          effect.size <- reactive(as.numeric(input$effect.size_sn))\n          clusterNums = 1:50\n          \n          plotTable <- reactive(data.frame(clusterNum = clusterNums,\n                                           clusterSize = ctsClus_getClusterSize_clusterNum(clusterNum.list = clusterNums,\n                                                                                           effect.size = effect.size(),\n                                                                                           resid.var = resid.var(),\n                                                                                           cluster.var = cluster.var(),\n                                                                                           alpha = alpha())))\n          myPlot <- ggplot(plotTable(), aes(x = clusterNum, y = clusterSize)) +\n            # geom_smooth(se = FALSE, method = \"loess\", size = 1, colour = \"blue\") +\n            geom_line(size = 1, colour = \"blue\") +\n            ggtitle(paste(\"Cluster Size vs. # of Clusters\\nto obtain at least\", sprintf(\"%3.2f\", power()), \"with effect size\", sprintf(\"%3.2f\", effect.size()))) +\n            xlab(\"# Clusters\") +\n            ylab(\"Cluster Size\")\n          return(myPlot)\n        }\n         \n      # 2. specify cluster size and # clusters --> receive power vs. effect size\n        if (input$clusterRequest == \"power vs. effect size\"){\n\n          cluster.size <- reactive(as.numeric(input$cluster.size_pe))\n          cluster.num  <- reactive(as.numeric(input$cluster.num_pe))\n          effectSizes <- reactive(pretty(seq(0, 2*sqrt(resid.var()), length = 40), n = 40))\n          \n          plotTable <- reactive(data.frame(effectSize = effectSizes(),\n                                           power = ctsClus_getpower_effectSize(effectSizes(),\n                                                                               cluster.size = cluster.size(),\n                                                                               cluster.num = cluster.num(),\n                                                                               cluster.var = cluster.var(),\n                                                                               resid.var = resid.var(),\n                                                                               alpha = alpha())))\n          myPlot <- ggplot(plotTable(), aes(x = effectSize, y = power)) +\n                      # geom_smooth(se = FALSE, method = \"loess\", size = 1, colour = \"blue\") + \n                      geom_line(size = 1, colour = \"blue\") +\n                      ggtitle(paste(\"Power vs. Effect Size\\nfor\", cluster.num(), \"clusters of\", cluster.size(), \"observations each\")) +\n                      xlab(\"Effect Size\") + ylab(\"Power\") + geom_hline(yintercept = 0.80)\n          return(myPlot)\n          # Add text that specifies \"To achieve 80% power you need an effect size of ___\"\n\n        }\n      # 3. specify power and # clusters --> receive effect size vs. cluster size\n        if (input$clusterRequest == \"effect size vs. cluster size\"){\n          #browser()\n          power        <- reactive(as.numeric(input$power_es))\n          cluster.num  <- reactive(as.numeric(input$cluster.num_es))\n          clusterSizes <- seq(10, 200, by = 5)\n          \n          plotTable <- reactive(data.frame(clusterSize = clusterSizes,\n                                           effectSize = ctsClus_getEffectSize_clusterSize(clusterSizes,\n                                                                                          cluster.num = cluster.num(),\n                                                                                          power = power(),\n                                                                                          cluster.var = cluster.var(),\n                                                                                          resid.var = resid.var(),\n                                                                                          alpha = alpha())))\n          myPlot <- ggplot(plotTable(), aes(x = clusterSize, y = effectSize)) +\n            # geom_smooth(se = FALSE, method = \"loess\", size = 1, colour = \"blue\") +\n            geom_line(size = 1, colour = \"blue\") +\n            ggtitle(paste(\"Effect Size vs. Cluster Size\\nfor\", cluster.num(), \"clusters, power =\", sprintf(\"%3.2f\", power()))) +\n            xlab(\"Cluster Size\") + ylab(\"Effect Size\")\n          return(myPlot)\n        }\n\n      # 4. specify power and cluster size --> receive effect size vs. # clusters (discrete)\n        if (input$clusterRequest == \"effect size vs. # clusters\"){\n          cluster.size <- reactive(input$cluster.size_en)\n          power        <- reactive(input$power_en)\n          clusterNums <- 1:50\n          plotTable <- reactive(data.frame(clusterNum = clusterNums,\n                                           effectSize = ctsClus_getEffectSize_clusterNum(clusterNums,\n                                                                                         cluster.size = cluster.size(),\n                                                                                         power = power(),\n                                                                                         cluster.var = cluster.var(),\n                                                                                         resid.var = resid.var(),\n                                                                                         alpha = alpha())))\n          myPlot <- ggplot(plotTable(), aes(x = clusterNum, y = effectSize)) + \n            # geom_smooth(se = FALSE, method = \"loess\", size = 1, colour = \"blue\") + \n            geom_line(size = 1, colour = \"blue\") +\n            ggtitle(paste(\"Effect Size vs. # of Clusters\\nfor\", cluster.size(), \"obs per cluster, power =\", sprintf(\"%3.2f\", power()))) +\n            xlab(\"# of Clusters\") + ylab(\"Effect Size\")\n          return(myPlot)\n        }\n    } else { # i.e. if input$clusterDesign != T\n      cluster.num <- 1\n      \n      # 1. specify effect size, receive power vs. sample size\n        if (input$indvRequest == \"power vs. sample size\"){\n          effect.size <- reactive(input$effect.size_psIndv)\n          sampleSizes <- seq(10, 1000, by = 5)\n          \n#           plotTable <- reactive(data.frame(sampleSize = sampleSizes, power = ctsClus_getpower_clusterSize(sampleSizes)))\n#           XXX Not yet developed\n#           plotOut <- ggplot(plotTable(), aes(x = sampleSize, y = power)) + \n#             # geom_smooth(se = FALSE, method = \"loess\", size = 1, colour = \"blue\") + \n#             geom_line(size = 1, colour = \"blue\") +\n#             ggtitle(paste(\"Power vs. Sample Size\\nfor effect size of\", sprintf(\"%3.2f\", effect.size()))) +\n#             xlab(\"Effect Size\") + ylab(\"Power\") + geom_hline(yintercept = 0.80)  \n        }        \n\n      # 2. Specify sample size, receive power vs. effect size\n        if (input$indvRequest == \"power vs. effect size\"){\n          sample.size <- reactive(input$sample.size_peIndv)\n          effectSizes <- reactive(pretty(seq(0, 2*sqrt(resid.var()), length = 40), n = 40))\n        \n          plotTable <- reactive(data.frame(effectSize = effectSizes(),\n                                           power = ctsClus_getpower_effectSize(effectSizes(),\n                                                                               cluster.num = cluster.num,\n                                                                               cluster.size = sample.size(),\n                                                                               cluster.var = cluster.var(),\n                                                                               resid.var = resid.var(),\n                                                                               alpha = alpha())))\n\n          myPlot <- ggplot(plotTable(), aes(x = effectSize, y = power)) +\n            # geom_smooth(se = FALSE, method = \"loess\", size = 1, colour = \"blue\") + \n            geom_line(size = 1, colour = \"blue\") +\n            ggtitle(paste(\"Power vs. Effect Size\\nfor sample size of\", sample.size())) +\n            xlab(\"Effect Size\") +\n            ylab(\"Power\") +\n            geom_hline(yintercept = 0.80)\n  \n          return(myPlot)\n        }\n\n      # 3. Specify power, receive effect size vs. sample size\n        if (input$indvRequest == \"effect size vs. sample size\"){\n          power <- reactive(as.numeric(input$power_esIndv))\n          sampleSizes <- seq(10, 1000, by = 100)\n          \n          plotTable <- reactive(data.frame(sampleSize = sampleSizes,\n                                           effectSize = ctsClus_getEffectSize_clusterSize(clusterSize.list = sampleSizes,\n                                                                                          cluster.num = cluster.num,\n                                                                                          power = power(),\n                                                                                          cluster.var = cluster.var(),\n                                                                                          resid.var = resid.var(),\n                                                                                          alpha = alpha())))\n          \n          myPlot <- ggplot(plotTable(), aes(x = sampleSize, y = effectSize)) +\n            # geom_smooth(se = FALSE, method = \"loess\", size = 1, colour = \"blue\") + \n            geom_line(size = 1, colour = \"blue\") +\n            ggtitle(paste(\"Effect Size vs. Sample Size\\nfor power = \", sprintf(\"%3.2f\", power()))) +\n            xlab(\"Sample Size\") +\n            ylab(\"Effect Size\")\n  \n          return(myPlot)\n        }\n\n    } # End of code pertaining to unclustered continuous outcome designs\n  \n  } else if (input$outcomeType == \"Binary\"){ # Code for binary outcome designs\n    \n    if (input$clusterDesign == T){\n        \n      # Run simulation with clustering according to specified parameters\n      Results <- reactive({\n        # Isolate all of the following assignments to not allow them to run until the \"Run Sim\" button is clicked\n        # Great description of isolation: http://shiny.rstudio.com/articles/isolation.html\n        #         input$runSim # NSM: This creates dependency (i.e. will rerun this code) every time the \"run sim\" button is clicked.\n                   #      The trick is to isolate this run from all other changes of parameters, until the user is ready \n                   #        to run. I'm not quite sure how to do this but, somehow, this example does it: https://github.com/rstudio/shiny-examples/blob/master/060-retirement-simulation/server.r\n      })\n\n    } else { # Code for unclustered designs\n      # Run unclustered analysis of binary outcome\n    }\n  } # End of binary designs\n  } # This is the hierarchy of {cts/bin, clustered, requeset}\n\n  })\n\n  # Table output\n#   output$table <- renderTable(Results())\n  \n#   output$downloadData <- downloadHandler(\n#     filename = \"sim-results-out.csv\",\n#     content = function(file) {\n#       write.csv(Results(), file, row.names = FALSE)\n#     }\n#   )\n\n})\n",
    "created" : 1437106961403.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "3784706044",
    "id" : "F370B28F",
    "lastKnownWriteTime" : 1437364705,
    "path" : "~/GitHub/sim-based-power-calculator/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}